Leetcode Medium
(NSBM)

1828. Queries on Number of Points Inside a Circle
You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.

You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.

For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.

Return an array answer, where answer[j] is the answer to the jth query.
Example 1:
Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
Output: [3,2,2]
Explanation: The points and circles are shown above.
queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.
Example 2:
Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
Output: [2,3,2,4]
Explanation: The points and circles are shown above.
queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.
 

Constraints:

1 <= points.length <= 500
points[i].length == 2
0 <= x​​​​​​i, y​​​​​​i <= 500
1 <= queries.length <= 500
queries[j].length == 3
0 <= xj, yj <= 500
1 <= rj <= 500
All coordinates are integers.

Solution->
/* here we simply use the distance formula and circle equation.
   sqrt((x1-x2)^2 - (y1-y2)^2) = distance between points (x1,y1) and (x2,y2).
   x^2 + y^2 = r^2 ---circle equation.
*/
class Solution {
public:
    vector<int> countPoints(vector<vector<int>>& pt, vector<vector<int>>& q) {
        int lq = q.size();
        int lpt = pt.size();
        vector<int> ans(lq);
        
        for(int i=0;i<lq;i++){ //for each queries
           int x = q[i][0];
            int y = q[i][1];
            int r = q[i][2];
            for(int j=0;j<lpt;j++){ //for each points
                if( ((x - pt[j][0]) * (x - pt[j][0]) + (y - pt[j][1]) * (y - pt[j][1])) <= r*r )
                    ans[i]++;
            }
        }
        
        
        return ans;
    }
};




1829. Maximum XOR for Each Query
(SBM)
Difficulty:Medium
You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:

Find a non-negative integer k < 2maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.
Remove the last element from the current array nums.
Return an array answer, where answer[i] is the answer to the ith query.

 

Example 1:

Input: nums = [0,1,1,3], maximumBit = 2
Output: [0,3,2,3]
Explanation: The queries are answered as follows:
1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
4th query: nums = [0], k = 3 since 0 XOR 3 = 3.
Example 2:

Input: nums = [2,3,4,7], maximumBit = 3
Output: [5,2,6,5]
Explanation: The queries are answered as follows:
1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
4th query: nums = [2], k = 5 since 2 XOR 5 = 7.
Example 3:

Input: nums = [0,1,2,2,5,7], maximumBit = 3
Output: [4,3,6,4,6,7]
 

Constraints:

nums.length == n
1 <= n <= 105
1 <= maximumBit <= 20
0 <= nums[i] < 2maximumBit
nums​​​ is sorted in ascending order.

Solution->
class Solution {
public:
    vector<int> getMaximumXor(vector<int>& a, int maximumBit) {
        
        int t = pow(2,maximumBit) - 1;
       // cout<<"t "<<t<<"\n";
        int l = a.size();
        vector<int> ans(l);
        int temp = a[0] ^ t;
        ans[0] = temp;
        for(int i=1;i<l;i++){
            ans[i] = temp ^ a[i];
            temp = ans[i];
        }
        
        reverse(ans.begin(), ans.end());
        return ans;
    }
};